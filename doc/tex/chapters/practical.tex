%!TEX root = /Users/nebolsin/Documents/MSU/Graduate Work/tex/main.tex
\section{Реализация прототипа РВС}   
\label{practical}

В рамках данной работы был реализован рабочий прототип РВС, ориентированный на работу с высокопроизводительными суперкомпьютерами и исследование параллельных алгоритмов.

Система реализована как web-проект, написанный при помощи фреймворка Ruby On Rails.   
                                    
Система установлена и настроена на использование вычислительных мощностей факультета ВМиК:
\begin{itemize}
  \item Основной сервер (angel.cs.msu.su). Данный сервер контролирует всю работу системы и предоставляет веб-интерфейс для пользователей.
  \item Вычислительный узел 1 (bluegene1.hpc). IBM Blue Gene/P — массивно-параллельная вычислительная система, которая состоит из двух стоек, включающих 8192 процессорных ядер (2 x 1024 четырехядерных вычислительных узлов), с пиковой производительностью 27,9 терафлопс (27,8528 триллионов операций с плавающей точкой в секунду).   
  \item Вычислительный узел 2 (regatta.hpc). Сервер IBM pSeries 690 Regatta, установленный на факультете --- это крупный сервер масштаба предприятия, состоящий из 16 процессоров Power4 и имеющий 64GB оперативной памяти.
\end{itemize}                                                                                           

Далее в этом разделе будут более детально описаны все составные части реализованной системы и использованные технологии.

\subsection{Структура доменных классов}

\begin{itemize}
  \item \textbf{Component.} Описывает вычислительный компонент в системе. 
    \begin{itemize}
      \item \emph{name}: название компонента;
      \item \emph{description}: подробное текстовое описание выполняемых компонентом функций;
      \item \emph{sources}: специальным образом оформленный архив с исполняемым кодом компонента;
      \item \emph{has\_many :simulations}: история запусков компонента;
      \item \emph{created\_at}: дата создания компонента;
      \item \emph{updated\_at}: дата последней модификации компонента.
    \end{itemize}
  \item \textbf{Simulation.} Описывает отдельный запуск вычислительного компонента.
    \begin{itemize}
      \item \emph{belongs\_to :component}: компонент, который был запущен;
      \item \emph{belongs\_to :computer}: вычислительный узел, на котором был запущен компонент;
      \item \emph{belongs\_to :user}: пользователь, запустивший вычисления;
      \item \emph{job\_id}: идентификатор присвоенный поставленной задаче планировщиком заданий вычислительного узла;
      \item \emph{status}: текущее состояние выполнения имитации;
      \item \emph{belongs\_to :result, :class\_name => `DataFile`}: файл с результатами выполнения имитации;
      \item \emph{created\_at}: дата создания компонента;
      \item \emph{updated\_at}: дата последней модификации компонента.
    \end{itemize}
  \item \textbf{Computer.} Описывает вычислительный узел, подключенный к системе.
    \begin{itemize}
      \item \emph{name}: название вычислительного узла;
      \item \emph{description}: подробное текстовое описание вычислительного узла;
      \item \emph{host}: сетевой адрес вычислительного узла;
      \item \emph{username}: имя пользователя, выделенного для работы системы на данном вычислительном узле;
      \item \emph{has\_many :components}: список компонентов, установленных на данном вычислительном узле.
    \end{itemize}
  \item \textbf{DataFile.} Описывает произвольный файл с пользовательскими данными. 
    \begin{itemize}
      \item \emph{name}: название файла с данными (может использоваться пользователем для представления файлов в системе понятными именами);
      \item \emph{description}: не обязательное текстовое описание файла с данными;
      \item \emph{content}: собственно файл с данными;
      \item \emph{belongs\_to :user}: владелец файла с данными. По-умолчанию к файлу имеет доступ только владелец и администратор. Однако пользователь может избирательно разрешить доступ к своим файлам с данными для других пользователей.
    \end{itemize}
  \item \textbf{User.}
    \begin{itemize}
      \item \emph{email}: электронный адрес пользователя, служит также в качестве логина;
      \item \emph{password}: пароль хранится в зашифрованном виде;
      \item \emph{salt}: дополнительная мера безопасности, случайная строка, использующаяся при проверке правильности пароля;
      \item \emph{full\_name}: полное имя пользователя;
      \item \emph{has\_many :data\_files}: файлы данных, принадлежащих пользователю;
      \item \emph{has\_many :simulations}: все имитации, запущенные данным пользователем.
    \end{itemize}
\end{itemize}      

\subsection{Организация пользовательского интерфейса}

Пользовательский интерфейс в разрабатываемой системе реализован в виде набора web-страниц. Такой способ организации интерфеса был выбран в связи с тем, что не требует установки дополнительного программного обеспечения на клиентском компьютере и на данный момент практически каждый человек имеет доступ к компьютеру с установленным на ним web-браузером.

Пользовательский интерфейс имеет три основных части: публичную, пользовательскую и администраторскую.

Публичная часть общедоступна и содержит описание системы и каталог имеющихся компонентов.

Доступ к пользовательской части интерфейса может получить только человек, имеющий логин в системе. В данной части пользователю предоставляются инструменты для загрузки данных, запуска вычислений, а также создания новых компонентов. Пользователь также имеет возможность просмотреть очереди заданий на вычислительных узлах системы и управлять заданиями, которые поставил он сам (например, отменить задание).

Администраторская часть интерфейса предназначена для создания пользователей и управления их правами, подключения новых вычислительных узлов к системе и контроля за ее использованием.

\subsection{Набор серверных скриптов}    

Одним из ключевых модулей системы является набор серверных скриптов, которые должны быть установлены администратором на каждый вычислительный узел, подключаемый к системе. Эти скрипты выполняют функцию взаимодействия между основным сервером системы и вычислительным узлом. 

В условиях распределенной среды, на вычислительных узлах зачастую установлены разные операционные системы, разные планировщики заданий и разные компиляторы. Основной задачей серверных скриптов является предоставление унифицированного интерфейса к данным программным средствам.

Каждый скрипт является отдельным исполняемым файлом и теоретически может быть написан на любом языке программирования. Практически, однако, рекомендуется использовать Bash Script или Ruby, в связи с доступностью и удобством данных скриптовых языков.            

При подключении к системе нового вычислительного модуля администратор должен поправить все серверные скрипты, учитывая особенности конкретной архитектуры, используемый планировщик заданий, а также размещение компиляторов и библиотек.

Набор серверных скриптов включает в себя следующие исполняемые файлы.
\begin{itemize}
  \item \textbf{queue} --- возвращает текущую очередь заданий на вычислительном узле;   
  \item \textbf{cancel\_job} --- отменяет задание, поставленное на вычисление;
  \item \textbf{install\_compomnent} --- устанавливает компонент на вычислительный узел;
  \item \textbf{simulate} --- ставит задание на запуск компонента на вычислительном узле;
  \item \textbf{retrieve\_result} --- получает файл с результатом, полученным в результате имитации.
\end{itemize}

\subsection{Используемые технологии}

\subsubsection{Ruby}   

Создатель Ruby --- Юкихиро Мацумото (Matz) —--- интересовался языками программирования ещё будучи студентом, но идея о разработке нового языка появилась позже. Ruby начал разрабатываться 24 февраля 1993 года и вышел в свет в 1995 году. Название навеяно языком Perl, многие особенности синтаксиса и семантики из которого заимствовано в Ruby (англ. pearl — «жемчужина», англ. ruby — «рубин»).

Целью разработки было создание «настоящего объектно-ориентированного», лёгкого в разработке, интерпретируемого языка программирования.

В Японии Ruby стал популярным с момента появления первой общедоступной версии в 1995 году, однако наличие документации только на японском языке сдерживало его дальнейшее распространение. Лишь в 1997 году появилось описание Ruby на английском языке, а в 1998 году открылся форум «ruby-talk». Это положило начало росту известности языка в остальном мире. Издано несколько книг на различных языках, в том числе на русском. Сейчас Ruby входит в большинство дистрибутивов ОС GNU/Linux, доступен пользователям других операционных систем.
                                                                                                                           
Основное назначение Ruby —-- создание простых и в то же время понятных программ, где важна не скорость работы программы, а малое время разработки, понятность и простота синтаксиса.

Язык следует принципу «наименьшей неожиданности»: программа должна вести себя так, как ожидает программист. Однако, в контексте Ruby это означает наименьшее удивление не при знакомстве с языком, а при его основательном изучении. Сам Мацумото утверждает, что целью разработки была минимизация неожиданностей при программировании для него, но после распространения языка он с удивлением узнал, что мышление программистов похоже и для многих их принцип «наименьшей неожиданности» совпал с его принципом.

Ruby также унаследовал идеологию языка программирования Perl в части предоставления программисту возможностей достижения одного и того же результата несколькими различными способами. Люди различны, и им для свободы необходима возможность выбирать.

Одной из основных целей разработки было освобождение программистов от рутинной работы, которую компьютер может выполнять быстрее и качественнее. Особое внимание, в частности, уделялось будничным рутинным занятиям (обработка текстов, администрирование), и для них язык настроен особенно хорошо.

В противовес машинно-ориентированным языкам, работающим быстрее, целью этой разработки был язык, наиболее близкий к человеку. Любая работа с компьютером выполняется людьми и для людей, и необходимо заботиться в первую очередь о затрачиваемых усилиях людей. Язык позволяет максимально быстро и просто для человека выполнить задачу, хотя, возможно, это и потребует дополнительного времени работы компьютера.

Основные характеристики языка Ruby:
\begin{itemize}
  \item Имеет лаконичный и простой синтаксис, частично разработанный под влиянием Ада, Эйфель и Python.
  \item Позволяет обрабатывать исключения в стиле Java и Python.
  \item Позволяет переопределять операторы, которые на самом деле являются методами.
  \item Полностью объектно-ориентированный язык программирования. Все данные в Ruby являются объектами в понимании Smalltalk. Единственное исключение — управляющие конструкции, которые в Ruby в отличие от Smalltalk не являются объектами. Например, число «1» — это экземпляр класса Fixnum. Также поддерживается добавление методов в класс и даже в конкретный экземпляр во время выполнения программы.
  \item Не поддерживает множественное наследование, но вместо него может использоваться концепция «примесей», основанная в данном языке на механизме модулей.
  \item Содержит автоматический сборщик мусора. Он работает для всех объектов Ruby, в том числе для внешних библиотек.
  \item Создавать расширения для Ruby на Си очень просто частично из-за сборщика мусора, частично из-за несложного и удобного API.
  \item Поддерживает замыкания с полной привязкой к переменным.
  \item Поддерживает блоки кода (код заключается в \{ … \} или do … end). Блоки могут использоваться в методах или преобразовываться в замыкания.
  \item Целые переменные в Ruby автоматически конвертируются между типами Fixnum (32-разрядные) и Bignum (больше 32 разрядов) в зависимости от их значения, что позволяет производить целочисленные математические расчёты со сколь угодно большой точностью.
  \item Не требует предварительного объявления переменных, но для интерпретатора желательно, чтобы переменным присваивалось пустое значение nil (тогда интерпретатор знает, что идентификатор обозначает переменную, а не имя метода). Язык использует простые соглашения для обозначения области видимости. Пример: просто var —- локальная переменная, @var —- переменная экземпляра (свойство или поле объекта класса), @@var —- переменная класса, \$var —- глобальная переменная.
  \item В Ruby непосредственно в языке реализованы многие шаблоны проектирования, так, например, «одиночка» (singleton) может быть (хотя и не обязан) реализован добавлением необходимых методов к одному конкретному объекту.
  \item Может динамически загружать расширения, если это позволяет операционная система.
  \item Имеет независимую от ОС поддержку невытесняющей многопоточности.
  \item Перенесён на множество платформ. Он разрабатывался на GNU/Linux, но работает на многих версиях Unix, DOS, Microsoft Windows (в частности, Win32), Mac OS, BeOS, OS/2 и т. д.
\end{itemize}


\subsubsection{Rails}   

Ruby on Rails (RoR) — объектно-ориентированный программный каркас для создания веб-приложений, написанный на языке программирования Ruby. Он был создан Дэвидом Хейнемеером Ханссоном на основе его работы над средством управления проектами Basecamp и выпущен в июле 2004 года. Последней версией является 2.3, выпущенная 16 марта 2009 года. Ruby on Rails предоставляет архитектурный образец Model-View-Controller (модель-представление-контроллер) для веб-приложений, обеспечивает их интеграцию с веб-сервером и сервером базы данных а также предоставляет однородную среду для разработки динамических AJAX-интерфейсов, с обработкой запросов и выдачи данных в контроллерах, отражения предметной области в базе данных.

Ruby on Rails является открытым программным обеспечением и распространяется под лицензией MIT.

Ruby on Rails определяет следующие принципы разработки приложений:
\begin{itemize}
	\item Приложения не должны определять собственную архитектуру, поскольку они используют готовый каркас модель-представление-контроллер.
	\item Язык Ruby позволяет использовать легко читаемую нотацию для определения семантики приложений (таких как отношения между таблицами в базе данных).
	\item Ruby on Rails предоставляет механизмы повторного использования, позволяющие минимизировать дублирование кода в приложениях (принцип Don’t Repeat Yourself).
	\item По умолчанию используются соглашения по конфигурации, типичные для большинства приложений (принцип Convention over configuration). Явная спецификация конфигурации требуется только в нестандартных случаях.
\end{itemize}      

Основными компонентами приложений Ruby on Rails являются модель (model), представление (view) и контроллер (controller).

Модель предоставляет остальным компонентам приложения объектно-ориентированное представление данных (таких как каталог продуктов или список заказов). Объекты модели осуществляют загрузку и сохранение данных в реляционной базе данных, а также реализуют бизнес-логику.

Благодаря возможностям динамической типизации в языке Ruby разработчику достаточно наследовать свой класс модели от базового класса ActiveRecord::Base. Ruby on Rails автоматически связывает классы модели с таблицами в базе данных и создает атрибуты объектов для соответствующих полей таблицы.

Представление создает пользовательский интерфейс для отображения полученных от контроллера данных. Представление также передает запросы пользователя на манипуляцию данными в контроллер (как правило, представление не изменяет непосредственно модель).

В Ruby on Rails представление описывается при помощи шаблонов RHTML. Они представляют собой файлы HTML с дополнительными включениями фрагментов кода Ruby (Embedded Ruby или ERb). Вывод, сгенерированный встроенным кодом Ruby, включается в текст шаблона, после чего получившаяся страница HTML возвращается пользователю. Представления могут использовать фрагменты других представлений и, в свою очередь, быть включенными в шаблон (layout) более высокого уровня.

Контроллер —-- основной компонент, отвечающий за взаимодействие с пользователем. Контроллер считывает необходимые данные из модели и подготавливает их для отображения, а также сохраняет полученные от отображения данные в модели.

\subsubsection{PostgreSQL}

PostgreSQL ведет свою «родословную» от некоммерческой СУБД Postgres, разработанной, как и многие open-source проекты, в Калифорнийском университете в Беркли. К разработке Postgres, начавшейся в 1986-ом году, имел непосредственное отношение Майкл Стоунбрейкер, руководитель более раннего проекта Ingres, на тот момент уже приобретённого компанией Computer Associates. Само название «Postgres» расшифровывалось как «Post Ingres», соответственно, при создании Postgres были применены многие уже ранее сделанные наработки.

Стоунбрейкер и его студенты разрабатывали новую СУБД в течение восьми лет, с 1986 по 1994 год. За этот период в синтаксис были введены процедуры, правила, пользовательские типы и многие другие компоненты. Работа не прошла даром — в 1995 разработка снова разделилась: Стоунбрейкер использовал полученный опыт в создании коммерческой СУБД Illustra, продвигаемой его собственной одноимённой компанией (приобретённой в последствие компанией Informix), а его студенты разработали новую версию Postgres — Postgres95, в которой язык запросов POSTQUEL — наследие Ingres — был заменен на SQL.

В этот момент разработка Postgres95 была выведена за пределы университета и передана команде энтузиастов. С этого момента эта СУБД получила имя, под которым она известна и развивается в текущий момент —-- PostgreSQL.

Сильными сторонами PostgreSQL считаются:
\begin{itemize}
	\item поддержка БД практически неограниченного размера;
	\item мощные и надёжные механизмы транзакций и репликации;
	\item наследование;
	\item легкая расширяемость.
\end{itemize}

\subsubsection{SSH}

SSH (англ. Secure Shell — «безопасная оболочка») —-- сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов). Сходен по функциональности с протоколами Telnet и rlogin, но, в отличие от них, шифрует весь трафик, включая и передаваемые пароли. SSH допускает выбор различных алгоритмов шифрования. SSH-клиенты и SSH-серверы имеются для большинства сетевых операционных систем.

SSH позволяет безопасно передавать в незащищенной среде практически любой другой сетевой протокол, таким образом, можно не только удаленно работать на компьютере через командную оболочку, но и передавать по шифрованному каналу звуковой поток или видео (например, с веб-камеры). Также SSH может использовать сжатие передаваемых данных для последующего их шифрования, что удобно, например, для удаленного запуска клиентов X Window System.   

Первая версия протокола, SSH-1, была разработана в 1995 году исследователем Тату Улёнен из Технологического университета Хельсинки, Финляндия. SSH-1 был написан для обеспечения большей конфиденциальности, чем протоколы rlogin, telnet и rsh. В 1996 году была разработана более безопасная версия протокола, SSH-2, несовместимая с SSH-1. Протокол приобрел ещё большую популярность, и к 2000 году его использовало уже порядка двух миллионов пользователей.

В 2006 году протокол был утвержден рабочей группой IETF в качестве Интернет-стандарта. Однако, в некоторых странах (Франция, Россия, Ирак и Пакистан) до сих пор требуется специальное разрешение в соответствующих структурах для использования определенных методов шифрования, включая SSH. 

Распространены две реализации SSH: коммерческая и бесплатная свободная. Свободная реализация называется OpenSSH. К 2006 году 80\% компьютеров сети Интернет использовало именно OpenSSH. Собственническая реализация разрабатывается организацией SSH Inc., она бесплатна для некоммерческого использования. Эти реализации содержат практически одинаковый набор команд.

Существуют две версии протокола SSH: SSH-1 и SSH-2. В первой версии протокола есть существенные недостатки, поэтому в настоящее время SSH-1 практически нигде не применяется.

Протокол SSH-2 в отличие от протокола telnet устойчив к атакам прослушивания трафика («снифинг»), то есть, прослушивание трафика ничего не дает злоумышленнику. Но неустойчив к атакам «man-in-middle». Протокол SSH-2 также устойчив к атакам путем присоединения посредине (англ. session hijacking) --- невозможно включиться в или перехватить уже установленную сессию.

Для предотвращения атак «man-in-middle» при подключении к хосту, ключ которого еще не известен клиенту, клиентское ПО показывает пользователю «слепок ключа» (key fingerprint). Рекомендуется тщательно проверять показываемый клиентским ПО «слепок ключа» (key fingerprint) со слепком ключа сервера, желательно полученным по надежным каналам связи или лично.

Поддержка SSH реализована во всех UNIX-подобных системах, и на большинстве из них в числе стандартных утилит присутствуют клиент и сервер ssh. Существует множество реализаций SSH-клиентов и для не-UNIX ОС. Большую популярность протокол получил после широкого развития анализаторов трафика и способов нарушения работы локальных сетей, как альтернативное небезопасному протоколу Telnet решение для управления важными узлами.
                                                                                                              


